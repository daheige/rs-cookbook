# rust高级特性
    rust高级特性
## 不安全性
Rust 还隐藏有第二种语言，它不会强制执行这类内存安全保证：这被称为 不安全 Rust（unsafe Rust）。它
与常规 Rust 代码无异，但是会提供额外的超能力。
不安全 Rust 之所以存在，是因为静态分析本质上是保守的。当编译器尝试确定一段代码是否
支持某个保证时，拒绝一些合法的程序比接受无效的程序要好一些。这必然意味着有时代码可
能是合法的，但如果 Rust 编译器没有足够的信息来确定，它将拒绝该代码。在这种情况下，
可以使用不安全代码告诉编译器，“相信我，我知道自己在干什么。” 不过千万注意，使用不安
全 Rust 风险自担：如果不安全代码出错了，比如解引用空指针，可能会导致不安全的内存使
用。

另一个 Rust 存在不安全一面的原因是底层计算机硬件固有的不安全性。如果 Rust 不允许进行
不安全操作，那么有些任务则根本完成不了。Rust 需要能够进行像直接与操作系统交互甚至
于编写你自己的操作系统这样的底层系统编程。底层系统编程也是 Rust 语言的目标之一。

要切换到 unsafe Rust，可以使用 unsafe 关键字，然后开启一个包含不安全代码的新块。这
里有五类可以在不安全 Rust 中进行而不能用于安全 Rust 的操作，它们称之为不安全的超能力
（unsafe superpowers）。这些超能力包括：
- 解引用裸指针
- 调用不安全的函数或方法 
- 访问或修改可变静态变量 
- 实现不安全 trait 
- 访问 union 的字段

有一点很重要，unsafe 并不会关闭借用检查器或禁用任何其他 Rust 安全检查：如果在不安全
代码中使用引用，它仍会被检查。unsafe 关键字只是提供了那五个不会被编译器检查内存安
全的功能。你仍然能在不安全块中获得某种程度的安全。

再者，unsafe 不意味着块中的代码就一定是危险的或者必然导致内存安全问题：其意图在于
作为程序员，你将会确保 unsafe 块中的代码以有效的方式访问内存。

人难免出错，错误总会发生，不过通过要求这五类不安全操作必须位于标记为 unsafe 的块中，
就能够知道任何与内存安全相关的错误必定位于 unsafe 块内。保持 unsafe 块尽可能小；如此，
当之后调查内存 bug 时就会感谢你自己了。

为了尽可能隔离不安全代码，最好将不安全代码封装进一个安全的抽象并提供安全 API，当我
们学习不安全函数和方法时会讨论到。标准库的一部分被实现为在被评审过的不安全代码之上
的安全抽象。这个技术防止了 unsafe 泄露到所有你或者用户希望使用由 unsafe 代码实现的功
能的地方，因为使用其安全抽象是安全的。

## 解引用裸指针
不安全 Rust 有两个被称为 裸指针（raw pointers）的类似于引用的新类型。
和引用一样，裸指针是不可变或可变的，分别写作 `*const T` 和 `*mut T`。
这里的星号不是解引用运算符；它是类型名称的一部分。

在裸指针的上下文中，不可变 意味着指针解引用之后不能直接赋值。
裸指针与引用和智能指针的区别在于
- 允许忽略借用规则，可以同时拥有不可变和可变的指针，或多个指向相同位置的可变指针 
- 不保证指向有效的内存 
- 允许为空 
- 不能实现任何自动清理功能

通过去掉 Rust 强加的保证，你可以放弃安全保证以换取性能或使用另一个语言或硬件接口的
能力，此时 Rust 的保证并不适用。

## 何时使用不安全代码
使用 unsafe 来进行这五个操作（超能力）之一是没有问题的，甚至是不需要深思熟虑的，不
过使得 unsafe 代码正确也实属不易，因为编译器不能帮助保证内存安全。当有理由使用
unsafe 代码时，是可以这么做的，通过使用显式的 unsafe 标注可以更容易地在错误发生时追
踪问题的源头。